<!DOCTYPE html>
<html lang="en">
  <head>
    <title>three.js webgl - transform controls</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <link type="text/css" rel="stylesheet" href="main.css">
  </head>
  <body>

    <!-- <div id="info">
      "W" translate | "E" rotate | "R" scale | "+/-" adjust size<br />
      "Q" toggle world/local space |  "Shift" snap to grid<br />
      "X" toggle X | "Y" toggle Y | "Z" toggle Z | "Spacebar" toggle enabled<br />
      "C" toggle camera | "V" random zoom
    </div> -->

    <script type="module">

      import * as THREE from '/build/three.module.js';

      import { OrbitControls } from './controls/OrbitControls.js';
      import { TransformControls } from './controls/TransformControls.js';

      let cameraPersp, cameraOrtho, currentCamera;
      let scene, renderer, control, orbit;

      init();
      render();

      function init() {

        renderer = new THREE.WebGLRenderer();
        renderer.setPixelRatio( window.devicePixelRatio );
        renderer.setSize( window.innerWidth, window.innerHeight );
        document.body.appendChild( renderer.domElement );

        const aspect = window.innerWidth / window.innerHeight;

        cameraPersp = new THREE.PerspectiveCamera( 90, aspect, 0.01, 30000 );
        cameraOrtho = new THREE.OrthographicCamera( - 600 * aspect, 600 * aspect, 600, - 600, 0.01, 30000 );
        currentCamera = cameraPersp;

        currentCamera.position.set( 100, 400, 100 );

        const mouse = new THREE.Vector2();

        scene = new THREE.Scene();
        scene.add( new THREE.GridHelper( 1000, 10, 0x888888, 0x444444 ) );
        const axes = new THREE.AxesHelper(300);
        scene.add(axes);

        const light = new THREE.DirectionalLight( 0xffffff, 2 );
        light.position.set( 1, 1, 1 );
        scene.add( light );

        const texture = new THREE.TextureLoader().load( 'textures/crate.gif', render );
        texture.anisotropy = renderer.capabilities.getMaxAnisotropy();

        // const geometry = new THREE.BoxBufferGeometry( 200, 200, 200 );
        // const material = new THREE.MeshLambertMaterial( { map: texture, transparent: true } );

        // 直方体を作成
        const material = new THREE.MeshNormalMaterial();
        const geometry = new THREE.SphereGeometry(3, 3, 3);
        const mesh = new THREE.Mesh(geometry, material);
        scene.add(mesh);

        orbit = new OrbitControls( currentCamera, renderer.domElement );
        orbit.target.set(0, 0, 0)
        orbit.update();
        orbit.addEventListener( 'change', render );

        control = new TransformControls( currentCamera, renderer.domElement );
        control.addEventListener( 'change', render );

        control.addEventListener( 'dragging-changed', function ( event ) {

          orbit.enabled = ! event.value;

        } );

        var ishigaki_steps = 6;
        // クリックしたときにあらわれる補助線
        var line_geometry = new THREE.Geometry();
        var rec_y0plane = new THREE.Line( line_geometry, new THREE.LineBasicMaterial({color: 0xFFFFFF}));
        var ishigaki_line = new Array(5 * ishigaki_steps);
        for (let i=0; i<5*ishigaki_steps; i++) ishigaki_line[i] = (new THREE.Line( new THREE.Geometry, new THREE.LineBasicMaterial({color: 0xFFFFFF})));


        // 櫓の補助線
        var yagura_line_exist = false;
        var yagura_line = [];
        var yagura_steps = 5;

        // 屋根の補助線
        var yane_line_exist = false;
        var yane_line = [];
        // 垂木の補助線
        var taruki_line_exist = false;
        var taruki_line = [];
        // 入母屋破風の補助線
        var irimoya_line_exist = false;
        var irimoya_line = [];
        // 千鳥破風の補助線
        var hafu_line_exist = false;
        var hafu_line = [];

        var build_mode = false;
        var edit_mode = false;
        var click_count = 0; // クリック回数のカウント
        var ref_point = new Array(5); // クリックした座標の保持
        const mouse_on_y0plane = new THREE.Vector3(); // カメラからカーソルのレイとy=0の平面の交点
        const mouse_on_2pplane = new THREE.Vector3(); // カメラからカーソルのレイと指定した2点を通るxz平面に垂直な平面の交点

        const raycaster = new THREE.Raycaster();
        var currentObj = undefined;
        var currentSquare = undefined;

        var ishigaki_geometry = [];
        var yagura_geometry = [];

        window.onmousemove = function(e) {
          // 上向きベクトル算出
          var t = new THREE.Vector3(0, 1, 0).applyMatrix4(currentCamera.matrixWorld);

          // カメラの位置から注視点位置を引き、正規化
          var w = new THREE.Vector3().subVectors(currentCamera.position, orbit.target).normalize();
          // wとカメラの上向きベクトルの外積を計算し、正規化
          var u = new THREE.Vector3().crossVectors(w, t).normalize();
          // uとwの外積を計算し、正規化
          var v = new THREE.Vector3().crossVectors(u, w).normalize();

          // 視点座標系の軸ベクトル
          var axis_vec = new THREE.Vector3(u, v, w);

          // canvas要素上のXY座標
          const mouseX = e.clientX// - window.innerWidth / 2;
          const mouseY = e.clientY// - window.innerHeight / 2;
          // console.log(mouseX, mouseY, window.innerWidth, window.innerHeight);

          var xs_dy = ((mouseX + 0) - window.innerWidth / 2.0) / window.innerHeight * 2 * Math.tan(currentCamera.fov / 2 * Math.PI / 180);
          var xs_dy_u = new THREE.Vector3().copy(u).multiplyScalar(xs_dy);
          var ys_dy = ((mouseY + 0) - window.innerHeight / 2.0) / window.innerHeight * 2 * Math.tan(currentCamera.fov / 2 * Math.PI / 180);
          var ys_dy_v = new THREE.Vector3().copy(v).multiplyScalar(ys_dy);
          // カメラ位置からカーソル位置までの方向ベクトル
          var q = new THREE.Vector3().copy(xs_dy_u).add(ys_dy_v).add(w);
          // console.log(q);

          // qとy=0の平面との交点
          var x_3d = -1 * currentCamera.position.y / q.y * q.x + currentCamera.position.x;
          var z_3d = -1 * currentCamera.position.y / q.y * q.z + currentCamera.position.z;
          mouse_on_y0plane.set(x_3d, 0, z_3d);

          if (click_count == 1) {
            console.log("once");
            var A = ref_point[0].clone(), B = mouse_on_y0plane.clone();
            var rec_vertices = [];
            console.log(B);
            rec_vertices.push(new THREE.Vector3(A.x, 0, A.z));
            rec_vertices.push(new THREE.Vector3(B.x, 0, A.z));
            rec_vertices.push(new THREE.Vector3(B.x, 0, B.z));
            rec_vertices.push(new THREE.Vector3(A.x, 0, B.z));
            rec_vertices.push(new THREE.Vector3(A.x, 0, A.z));
            rec_vertices.push(new THREE.Vector3(B.x, 0, B.z));
            rec_y0plane.geometry.vertices = rec_vertices;
            rec_y0plane.geometry.verticesNeedUpdate = true;
            rec_y0plane.geometry.elementNeedUpdate = true;
            rec_y0plane.geometry.computeFaceNormals();
          } else if (click_count == 2) {
            // 平面の指定した2点を通り、y軸に平行な平面
            var vec_2points = new THREE.Vector3(ref_point[1].x - ref_point[0].x, 0, ref_point[1].z - ref_point[0].z); // 2点間方向ベクトル
            var normal_2points = new THREE.Vector3(-1 * vec_2points.z, 0, vec_2points.x); // 2点間の方向ベクトルの法線ベクトル
            // n = normal_2points、A = ref_point[0]とすると、直線の方程式は
            // nx(x-Ax)+nz(z-Az)=0 (ny=0よりyについては省略)

            // qと、平面の指定した2点を通りy軸に平行な平面との交点
            // 媒介変数t
            var t = (normal_2points.x * (ref_point[0].x - currentCamera.position.x) + normal_2points.z * (ref_point[0].z - currentCamera.position.z)) / (normal_2points.x * q.x + normal_2points.z * q.z);
            mouse_on_2pplane.set(
              q.x * t + currentCamera.position.x,
              q.y * t + currentCamera.position.y,
              q.z * t + currentCamera.position.z
              );
            // console.log(t);

            var initA = ref_point[0].clone(), initB = ref_point[1].clone(), initD = mouse_on_2pplane.clone();
            if (initD.y < 0) initD.y = 0;
            var initC = new THREE.Vector3(initB.x - (initD.x - initA.x), initD.y, initB.z - (initD.z - initA.z));

            var A = initA.clone(), B = initB.clone();
            // var C = new THREE.Vector3(initA.x + change_level_up.x, initA.y + change_level_up.y, initA.z + change_level_up.z);
            // var D = new THREE.Vector3(initB.x - change_level_up.x, initB.y + change_level_up.y, initB.z - change_level_up.z);
            var C = A.clone();
            var D = B.clone();

            var h = initC.y - initA.y;
            // // var curve = (initC.x - initD.x) / 3;
            // var curve = 0;
            // var b_x = (initA.x - initB.x) / 2 - curve;
            // var b_z = (initA.z - initB.z) / 2 - curve;
            // var d_x = (initC.x - initD.x) / 2 - curve;
            // var d_z = (initC.z - initD.z) / 2 - curve;
            var b_x = (initA.x - initC.x) * 50/44;
            var b_z = (initA.z - initC.z) * 50/44;
            var d_x = (initA.x - initC.x) * 6/44;
            var d_z = (initA.z - initC.z) * 6/44;

            var delta_x = ishigaki_steps / (ishigaki_steps - 1) * d_x / h;
            var delta_z = ishigaki_steps / (ishigaki_steps - 1) * d_z / h;

            function r(axis, sub) {
              let n = ishigaki_steps;

              if (axis == 0) {
                var r = b_x / h;
                if (sub == n - 1) {
                  return r;
                } else {
                  for (let i = (n-1); i > sub; i--) {
                    if (i != 0) r -= delta_x / i;
                  }
                  return r;
                }
              }

              if (axis == 2) {
                var r = b_z / h;
                if (sub == n - 1) {
                  return r;
                } else {
                  for (let i = (n-1); i > sub; i--) {
                    if (i != 0) r -= delta_z / i;
                  }
                  return r;
                }
              }
            }

            function change_level(axis, sub) {
              if (axis == 1) {
                return (initC.y - initA.y) / ishigaki_steps;
              } else {
                return r(axis, sub) * h / ishigaki_steps;
              }
            }

            for (let i = 0; i < ishigaki_steps; i++) {

              C.x -= change_level(0, (ishigaki_steps-1)-i);
              C.y += change_level(1, (ishigaki_steps-1)-i);
              C.z -= change_level(2, (ishigaki_steps-1)-i);
              D.x += change_level(0, (ishigaki_steps-1)-i);
              D.y += change_level(1, (ishigaki_steps-1)-i);
              D.z += change_level(2, (ishigaki_steps-1)-i);

              var ishigaki_line_vertices = [];
              ishigaki_line_vertices[0] = [];
              ishigaki_line_vertices[0].push(new THREE.Vector3(A.x, A.y, A.z));
              ishigaki_line_vertices[0].push(new THREE.Vector3(C.x, C.y, C.z));
              ishigaki_line_vertices[1] = [];
              ishigaki_line_vertices[1].push(new THREE.Vector3(A.x, A.y, B.z));
              ishigaki_line_vertices[1].push(new THREE.Vector3(C.x, C.y, D.z));
              ishigaki_line_vertices[2] = [];
              ishigaki_line_vertices[2].push(new THREE.Vector3(B.x, B.y, B.z));
              ishigaki_line_vertices[2].push(new THREE.Vector3(D.x, D.y, D.z));
              ishigaki_line_vertices[3] = [];
              ishigaki_line_vertices[3].push(new THREE.Vector3(B.x, B.y, A.z));
              ishigaki_line_vertices[3].push(new THREE.Vector3(D.x, D.y, C.z));
              ishigaki_line_vertices[4] = [];
              ishigaki_line_vertices[4].push(new THREE.Vector3(C.x, C.y, C.z));
              ishigaki_line_vertices[4].push(new THREE.Vector3(D.x, C.y, C.z));
              ishigaki_line_vertices[4].push(new THREE.Vector3(D.x, C.y, D.z));
              ishigaki_line_vertices[4].push(new THREE.Vector3(C.x, C.y, D.z));
              ishigaki_line_vertices[4].push(new THREE.Vector3(C.x, C.y, C.z));
              // ishigaki_line_vertices[4].push(new THREE.Vector3(D.x, C.y, D.z));

              console.log(A);

              for (let j=0; j<5; j++) {
                let num = i * 5 + j;
                ishigaki_line[num].geometry.vertices = ishigaki_line_vertices[j];
                ishigaki_line[num].geometry.verticesNeedUpdate = true;
                ishigaki_line[num].geometry.elementNeedUpdate = true;
                ishigaki_line[num].geometry.computeFaceNormals();
              }

              A = C.clone();
              B = D.clone();

            }
          } else if (click_count == 3) {
            // 平面の指定した2点を通り、y軸に平行な平面
            var vec_2points = new THREE.Vector3(ref_point[1].x - ref_point[0].x, 0, ref_point[1].z - ref_point[0].z); // 2点間方向ベクトル
            var normal_2points = new THREE.Vector3(-1 * vec_2points.z, 0, vec_2points.x); // 2点間の方向ベクトルの法線ベクトル
            // n = normal_2points、A = ref_point[0]とすると、直線の方程式は
            // nx(x-Ax)+nz(z-Az)=0 (ny=0よりyについては省略)

            // qと、平面の指定した2点を通りy軸に平行な平面との交点
            // 媒介変数t
            var t = (normal_2points.x * (ref_point[0].x - currentCamera.position.x) + normal_2points.z * (ref_point[0].z - currentCamera.position.z)) / (normal_2points.x * q.x + normal_2points.z * q.z);
            mouse_on_2pplane.set(
              q.x * t + currentCamera.position.x,
              q.y * t + currentCamera.position.y,
              q.z * t + currentCamera.position.z
              );
            mesh.position.set(mouse_on_2pplane.x, mouse_on_2pplane.y, mouse_on_2pplane.z);
            // console.log(t);

            if (yagura_line_exist == false) yagura_line_exist = true;
            render_yagura_line();
            render_yane_line();
          } else {
            mesh.position.set(mouse_on_y0plane.x, mouse_on_y0plane.y, mouse_on_y0plane.z);
            // console.log(ref_point[0]);
          }

          if (edit_mode) {
            const element = e.target;
            const width = element.offsetWidth;
            const height = element.offsetHeight;
            mouse.x = (mouseX / width) * 2 - 1;
            mouse.y = -(mouseY / height) * 2 + 1;

            raycaster.setFromCamera(mouse, currentCamera);
            const intersects = raycaster.intersectObjects(scene.children);

            if (intersects.length > 0) {
              var obj = intersects[0].object;
              var square = intersects[0].faceIndex;

              if (currentObj != obj || currentSquare != square) {
                if (square !== undefined) {
                  if (currentObj && currentSquare) {
                    currentObj.geometry.colorsNeedUpdate = true;
                    currentObj.geometry.faces[currentSquare].color.set(0xCBC9D4);
                    if (currentSquare == 10) currentObj.geometry.faces[11].color.set(0xCBC9D4);
                    if (currentSquare == 11) currentObj.geometry.faces[10].color.set(0xCBC9D4);
                  }

                  if (square == 10 || square == 11) {
                    obj.geometry.colorsNeedUpdate = true;
                    obj.geometry.faces[square].color.set(0x00ff00);
                    if (square == 10) obj.geometry.faces[11].color.set(0x00ff00);
                    if (square == 11) obj.geometry.faces[10].color.set(0x00ff00);
                  }

                  currentObj = obj;
                  currentSquare = square;
                  console.log(square)
                }
              }
            } else {
              if (currentObj) {
                currentObj.geometry.colorsNeedUpdate = true;
                currentObj.geometry.faces[currentSquare].color.set(0xCBC9D4);
                if (currentSquare == 10) currentObj.geometry.faces[11].color.set(0xCBC9D4);
                if (currentSquare == 11) currentObj.geometry.faces[10].color.set(0xCBC9D4);
              }
            }
          }

          render();
        }

        function render_yagura_line() {
          var initA = ref_point[2].clone(), initB = ref_point[3].clone()
          var initD = mouse_on_2pplane.clone();
          if (initD.x > initB.x) initD.x = initB.x;
          if (initD.x < (initB.x + initA.x) / 2) initD.x = (initB.x + initA.x) / 2;
          if (initD.y < initB.y) initD.y = initB.y;
          if (initD.z < initB.z) initD.z = initB.z;
          if (initD.z > (initB.z + initA.z) / 2) initD.z = (initB.z + initA.z) / 2;
          var initC = new THREE.Vector3(initB.x - (initD.x - initA.x), initD.y, initB.z - (initD.z - initA.z));

          var change_level = new THREE.Vector3(
            (initD.x - initB.x) / (yagura_steps - 1),
            (initD.y - initB.y) / yagura_steps,
            (initD.z - initB.z) / (yagura_steps - 1)
          )

          var A = initA.clone();
          var B = initB.clone();
          var C = new THREE.Vector3(
            initA.x,
            initA.y + change_level.y,
            initA.z,
          )
          var D = new THREE.Vector3(
            initB.x,
            initB.y + change_level.y,
            initB.z,
          )
          for (let i=0; i<yagura_steps; i++) {
            var yagura_line_vertices = [];
            yagura_line_vertices[0] = [];
            yagura_line_vertices[0].push(new THREE.Vector3(A.x, A.y, A.z));
            yagura_line_vertices[0].push(new THREE.Vector3(B.x, A.y, A.z));
            yagura_line_vertices[0].push(new THREE.Vector3(B.x, A.y, B.z));
            yagura_line_vertices[0].push(new THREE.Vector3(A.x, A.y, B.z));
            yagura_line_vertices[0].push(new THREE.Vector3(A.x, A.y, A.z));
            // yagura_line_vertices[0].push(new THREE.Vector3(B.x, A.y, B.z));
            yagura_line_vertices[1] = [];
            yagura_line_vertices[1].push(new THREE.Vector3(A.x, A.y, A.z));
            yagura_line_vertices[1].push(new THREE.Vector3(C.x, C.y, C.z));
            yagura_line_vertices[2] = [];
            yagura_line_vertices[2].push(new THREE.Vector3(A.x, A.y, B.z));
            yagura_line_vertices[2].push(new THREE.Vector3(C.x, C.y, D.z));
            yagura_line_vertices[3] = [];
            yagura_line_vertices[3].push(new THREE.Vector3(B.x, B.y, B.z));
            yagura_line_vertices[3].push(new THREE.Vector3(D.x, D.y, D.z));
            yagura_line_vertices[4] = [];
            yagura_line_vertices[4].push(new THREE.Vector3(B.x, B.y, A.z));
            yagura_line_vertices[4].push(new THREE.Vector3(D.x, D.y, C.z));
            yagura_line_vertices[5] = [];
            yagura_line_vertices[5].push(new THREE.Vector3(C.x, C.y, C.z));
            yagura_line_vertices[5].push(new THREE.Vector3(D.x, C.y, C.z));
            yagura_line_vertices[5].push(new THREE.Vector3(D.x, C.y, D.z));
            yagura_line_vertices[5].push(new THREE.Vector3(C.x, C.y, D.z));
            yagura_line_vertices[5].push(new THREE.Vector3(C.x, C.y, C.z));
            // yagura_line_vertices[5].push(new THREE.Vector3(D.x, C.y, D.z));

            for (let j=0; j<6; j++) {
              let index = i * 6 + j;
              yagura_line[index].geometry.vertices = yagura_line_vertices[j];
              yagura_line[index].geometry.verticesNeedUpdate = true;
              yagura_line[index].geometry.elementNeedUpdate = true;
              yagura_line[index].geometry.computeFaceNormals();
            }

            A.x -= change_level.x;
            A.y += change_level.y;
            A.z -= change_level.z;
            B.x += change_level.x;
            B.y += change_level.y;
            B.z += change_level.z;
            C.x -= change_level.x;
            C.y += change_level.y;
            C.z -= change_level.z;
            D.x += change_level.x;
            D.y += change_level.y;
            D.z += change_level.z;
          }
        }

        function render_yane_line() {
          var initA = ref_point[2].clone(), initB = ref_point[3].clone()
          var initD = mouse_on_2pplane.clone();
          if (initD.x > initB.x) initD.x = initB.x;
          if (initD.x < (initB.x + initA.x) / 2) initD.x = (initB.x + initA.x) / 2;
          if (initD.y < initB.y) initD.y = initB.y;
          if (initD.z < initB.z) initD.z = initB.z;
          if (initD.z > (initB.z + initA.z) / 2) initD.z = (initB.z + initA.z) / 2;
          var initC = new THREE.Vector3(initB.x - (initD.x - initA.x), initD.y, initB.z - (initD.z - initA.z));

          var change_level = new THREE.Vector3(
            (initD.x - initB.x) / (yagura_steps - 1),
            (initD.y - initB.y) / yagura_steps,
            (initD.z - initB.z) / (yagura_steps - 1)
          )

          var A = new THREE.Vector3(
            initA.x + change_level.x,
            initA.y + 5 * change_level.y / 6,
            initA.z + change_level.z,
          )
          var B = new THREE.Vector3(
            initB.x - change_level.x,
            initB.y + 5 * change_level.y / 6,
            initB.z - change_level.z,
          )
          var C = new THREE.Vector3(
            initA.x - change_level.x,
            initA.y + 8 * change_level.y / 6,
            initA.z - change_level.z,
          )
          var D = new THREE.Vector3(
            initB.x + change_level.x,
            initB.y + 8 * change_level.y / 6,
            initB.z + change_level.z,
          )

          var taruki_interval_x = -1 * change_level.x / 8;
          if (taruki_interval_x == 0.0) taruki_interval_x = 0.1;
          var taruki_interval_z = -1 * change_level.z / 8;
          if (taruki_interval_z == 0.0) taruki_interval_z = 0.1;
          var init_taruki_num_x = Math.round((initB.x - initA.x) / taruki_interval_x);
          var init_taruki_num_z = Math.round((initB.z - initA.z) / taruki_interval_z);
          var sei = change_level.y / 2 / init_taruki_num_x * 10;

          remove_taruki_line();

          hafu_line.forEach(function(it) {
            scene.remove(it);
          });
          hafu_line = [];

          var taruki_index = 0;

          for (let i=0; i<yagura_steps; i++) {
            var yane_line_vertices = [];
            var taruki_line_vertices = [];

            yane_line_vertices[0] = [];

            var taruki_num_x = Math.round((B.x - A.x) / taruki_interval_x);
            var taruki_num_z = Math.round((B.z - A.z) / taruki_interval_z);

            var yane_x = A.x;
            var yane_y = A.y;
            var yane_z = A.z;
            for (let direction=0; direction<4; direction++) {
              var taruki_num;

              if (direction % 2 == 0) {
                taruki_num = taruki_num_x;
              } else {
                taruki_num = taruki_num_z;
              }

              if (taruki_num > 100) taruki_num = 100;

              var count = 0;

              for (let j=0; j<taruki_num; j++) {
                if (j < 8) {
                  yane_y = A.y + sei * (8-j-1) * (8-j) / 8 / 7;
                } else if (j > taruki_num - 8) {
                  yane_y = A.y + sei * count * (count+1) / 8 / 7;
                  // console.log(yane_y);
                  count++;
                } else {
                  yane_y = A.y;
                }
                yane_line_vertices[0].push(new THREE.Vector3(yane_x, yane_y, yane_z));

                if (j % 4 == 0) {
                  taruki_line.push(new THREE.Line( new THREE.Geometry, new THREE.LineBasicMaterial({color: 0x0000FF})));
                  var taruki_line_vertices = [];
                  taruki_line_vertices.push(new THREE.Vector3(yane_x, yane_y, yane_z));
                  if (direction==0) {
                    var grad = (C.z - A.z) / (C.x - A.x);
                    var chanz = (change_level.z > grad * (A.x - yane_x)) ? grad * (A.x - yane_x) : change_level.z;
                    if (chanz == change_level.z) {
                      grad = (C.z - A.z) / (D.x - B.x);
                      chanz = (change_level.z > grad * (B.x - yane_x)) ? grad * (B.x - yane_x) : change_level.z;
                    }
                    taruki_line_vertices.push(new THREE.Vector3(yane_x, yane_y + change_level.y / 6 * chanz / change_level.z, yane_z - chanz));
                  } else if (direction==1) {
                    var grad = (D.x - B.x) / (C.z - A.z);
                    var chanx = (change_level.x < grad * (yane_z - A.z)) ? grad * (yane_z - A.z) : change_level.x;
                    if (chanx == change_level.x) {
                      grad = (D.x - B.x) / (D.z - B.z);
                      chanx = (change_level.x < grad * (yane_z - B.z)) ? grad * (yane_z - B.z) : change_level.x;
                    }
                    taruki_line_vertices.push(new THREE.Vector3(yane_x + chanx, yane_y + change_level.y / 6 * chanx / change_level.x, yane_z));
                  } else if (direction==2) {
                    var grad = (D.z - B.z) / (D.x - B.x);
                    var chanz = (change_level.z > grad * (yane_x - B.x)) ? grad * (yane_x - B.x) : change_level.z;
                    if (chanz == change_level.z) {
                      grad = (D.z - B.z) / (C.x - A.x);
                      chanz = (change_level.z > grad * (yane_x - A.x)) ? grad * (yane_x - A.x) : change_level.z;
                    }
                    taruki_line_vertices.push(new THREE.Vector3(yane_x, yane_y + change_level.y / 6 * chanz / change_level.z, yane_z + chanz));
                  } else if (direction==3) {
                    var grad = (C.x - A.x) / (D.z - B.z);
                    var chanx = (change_level.x < grad * (B.z - yane_z)) ? grad * (B.z - yane_z) : change_level.x;
                    if (chanx == change_level.x) {
                      grad = (C.x - A.x) / (C.z - A.z);
                      chanx = (change_level.x < grad * (A.z - yane_z)) ? grad * (A.z - yane_z) : change_level.x;
                    }
                    taruki_line_vertices.push(new THREE.Vector3(yane_x - chanx, yane_y + change_level.y / 6 * chanx / change_level.x, yane_z));
                  }
                  taruki_line[taruki_line.length - 1].geometry.vertices = taruki_line_vertices;
                  scene.add(taruki_line[taruki_line.length - 1]);
                }

                if (direction==0) {
                  yane_x += (B.x - A.x) / taruki_num;
                } else if (direction==1) {
                  yane_z += (B.z - A.z) / taruki_num;
                } else if (direction==2) {
                  yane_x -= (B.x - A.x) / taruki_num;
                } else if (direction==3) {
                  yane_z -= (B.z - A.z) / taruki_num;
                }

                taruki_index++;
              }
            }
            yane_line_vertices[0].push(new THREE.Vector3(A.x, A.y + sei, A.z));
            // yane_line_vertices[0].push(new THREE.Vector3(B.x, A.y, B.z));
            // yane_line_vertices[0].push(new THREE.Vector3(A.x, A.y, B.z));
            // yane_line_vertices[0].push(new THREE.Vector3(A.x, A.y, A.z));
            //// yane_line_vertices[0].push(new THREE.Vector3(B.x, A.y, B.z));

            var sumimune_steps = 5;

            function render_sumimune_line(vertices_array, Downx, Downy, Downz, Upx, Upy, Upz) {
              var horizontal_distance = Math.sqrt(Math.pow(Upx - Downx, 2) + Math.pow(Upz - Downz, 2));
              var grad = (Upy - (Downy + sei)) / Math.pow(horizontal_distance, 2);

              var delta_x = (Upx - Downx) / sumimune_steps;
              var delta_z = (Upz - Downz) / sumimune_steps;
              var yane_x = Downx, yane_y = Downy + sei, yane_z = Downz;
              for (let j=0; j<=sumimune_steps; j++) {
                yane_y = Downy + sei + grad * Math.pow(j, 2) * (Math.pow(delta_x, 2) + Math.pow(delta_z, 2));
                vertices_array.push(new THREE.Vector3(yane_x, yane_y, yane_z));
                yane_x += delta_x;
                yane_z += delta_z;
              }
            }

            yane_line_vertices[1] = [];
            render_sumimune_line(yane_line_vertices[1], A.x, A.y, A.z, C.x, C.y, C.z);

            yane_line_vertices[2] = [];
            render_sumimune_line(yane_line_vertices[2], A.x, A.y, B.z, C.x, C.y, D.z);
            // yane_line_vertices[2].push(new THREE.Vector3(A.x, A.y, B.z));
            // yane_line_vertices[2].push(new THREE.Vector3(C.x, C.y, D.z));
            yane_line_vertices[3] = [];
            render_sumimune_line(yane_line_vertices[3], B.x, B.y, B.z, D.x, D.y, D.z);
            // yane_line_vertices[3].push(new THREE.Vector3(B.x, B.y, B.z));
            // yane_line_vertices[3].push(new THREE.Vector3(D.x, D.y, D.z));
            yane_line_vertices[4] = [];
            render_sumimune_line(yane_line_vertices[4], B.x, A.y, A.z, D.x, C.y, C.z);
            // yane_line_vertices[4].push(new THREE.Vector3(B.x, B.y, A.z));
            // yane_line_vertices[4].push(new THREE.Vector3(D.x, D.y, C.z));
            yane_line_vertices[5] = [];
            // yane_line_vertices[5].push(new THREE.Vector3(C.x, C.y, C.z));
            // yane_line_vertices[5].push(new THREE.Vector3(D.x, C.y, C.z));
            // yane_line_vertices[5].push(new THREE.Vector3(D.x, C.y, D.z));
            // yane_line_vertices[5].push(new THREE.Vector3(C.x, C.y, D.z));
            // yane_line_vertices[5].push(new THREE.Vector3(C.x, C.y, C.z));
            //// yane_line_vertices[5].push(new THREE.Vector3(D.x, C.y, D.z));

            for (let j=0; j<6; j++) {
              let index = i * 6 + j;
              yane_line[index].geometry = new THREE.Geometry();
              yane_line[index].geometry.vertices = yane_line_vertices[j];
              yane_line[index].geometry.verticesNeedUpdate = true;
              yane_line[index].geometry.elementNeedUpdate = true;
              yane_line[index].geometry.computeFaceNormals();
            }

            if (i == 0 && i != yagura_steps - 1) {
              var hafu_ren = (A.z - B.z) / 5;
              var hafu_start = A.z - (A.z - B.z) / 2;
              var hafu_line_vertices = [];
              hafu_line_vertices[0] = [];
              hafu_line_vertices[1] = [];
              var hafu_steps = 6;

              var alpha = 0.45;
              var rho1 = 0.3, rho2 = 0.6, theta = Math.atan(0.28), H = hafu_ren * Math.tan(theta);
              var L = hafu_ren / Math.cos(theta), Dist = 0.08 * L;
              var hafu_z = new THREE.Vector2();
              var hafu_point = new THREE.Vector2();
              for (let j=0; j<=hafu_steps*2; j++) {
                if (j<=hafu_steps) {
                  var r1 = rho1 * Dist;
                  hafu_z.x = alpha * j * L / hafu_steps;
                  hafu_z.y = r1 * Math.sin(Math.PI * j / hafu_steps);

                } else {
                  var r2 = rho2 * Dist;
                  hafu_z.x = (alpha * hafu_steps + (1 - alpha) * (j - hafu_steps)) * L / hafu_steps;
                  hafu_z.y = r2 * Math.sin(Math.PI * j / hafu_steps);
                }
                  hafu_point.x = hafu_z.x * Math.cos(theta) + hafu_z.y * Math.sin(theta);
                  hafu_point.y = H - hafu_z.x * Math.sin(theta) + hafu_z.y * Math.cos(theta);
                  hafu_line_vertices[0].push(new THREE.Vector3(B.x, B.y + hafu_point.y, hafu_start + hafu_point.x));
                  hafu_line_vertices[1].push(new THREE.Vector3(B.x, B.y + hafu_point.y, hafu_start - hafu_point.x));
              }

              hafu_line.push(new THREE.Line( new THREE.Geometry, new THREE.LineBasicMaterial({color: 0x0000FF})));
              hafu_line[0].geometry.vertices = hafu_line_vertices[0];
              // scene.add(hafu_line[0]);
              hafu_line.push(new THREE.Line( new THREE.Geometry, new THREE.LineBasicMaterial({color: 0x0000FF})));
              hafu_line[1].geometry.vertices = hafu_line_vertices[1];
              // scene.add(hafu_line[1]);
            }

            if (i == 1 && i != yagura_steps - 1) {
              var hafu_ren = (B.x - A.x) / 2;
              var hafu_start = A.x + (B.x - A.x) / 2 - hafu_ren / 2;
              var hafu_line_vertices = [];
              hafu_line_vertices[0] = [];
              var hafu_steps = 5;
              var hafu_x = hafu_start, hafu_y, hafu_z = A.z - change_level.z / 3;
              var L = Math.sqrt(Math.pow(hafu_ren / 2, 2) + Math.pow(change_level.y, 2));
              var theta = Math.atan(change_level.y / (hafu_ren / 2));
              var alpha = 0.5;
              for (let j=0; j<=hafu_steps*2; j++) {
                var step = j <= hafu_steps ? j : hafu_steps*2 - j;
                hafu_y = A.y + step * L / hafu_steps * (Math.sin(theta) - alpha * (hafu_steps - step) / hafu_steps * Math.cos(theta));
                hafu_line_vertices[0].push(new THREE.Vector3(hafu_x, hafu_y, hafu_z));
                hafu_x += hafu_ren / 2 / hafu_steps;
              }

              hafu_line.push(new THREE.Line( new THREE.Geometry, new THREE.LineBasicMaterial({color: 0x0000FF})));
              hafu_line[hafu_line.length - 1].geometry.vertices = hafu_line_vertices[0];
              // scene.add(hafu_line[hafu_line.length - 1]);
            }

            if (i == yagura_steps - 1) {
              A.x -= 3 * change_level.x / 4;
              B.x += 3 * change_level.x / 4;
              A.z -= 3 * change_level.z / 4;
              B.z += 3 * change_level.z / 4;
              C.x = A.x;
              D.x = B.x;
              C.y += change_level.y / 3;
              D.y += change_level.y / 3;
              C.z = (C.z + D.z) / 2;
              D.z = C.z;

              var irimoya_line_vertices = [];
              irimoya_line_vertices[0] = [];
              irimoya_line_vertices[1] = [];
              irimoya_line_vertices[2] = [];
              var irimoya_steps = 5;
              var irimoya_z = A.z, irimoya_y = A.y;
              var L = Math.sqrt(Math.pow(C.z - A.z, 2) + Math.pow(C.y - A.y, 2));
              var theta = -1 * Math.atan((C.y - A.y) / (C.z - A.z));
              var alpha = 0.5;
              for (let j=0; j<=irimoya_steps*2; j++) {
                var step = j <= irimoya_steps ? j : irimoya_steps*2 - j;
                irimoya_y = A.y + step * L / irimoya_steps * (Math.sin(theta) - alpha * (irimoya_steps - step) / irimoya_steps * Math.cos(theta));
                irimoya_line_vertices[0].push(new THREE.Vector3(A.x, irimoya_y, irimoya_z));
                irimoya_z += (C.z - A.z) / irimoya_steps;
              }

              irimoya_z = A.z;
              for (let j=0; j<=irimoya_steps*2; j++) {
                var step = j <= irimoya_steps ? j : irimoya_steps*2 - j;
                irimoya_y = A.y + step * L / irimoya_steps * (Math.sin(theta) - alpha * (irimoya_steps - step) / irimoya_steps * Math.cos(theta));
                irimoya_line_vertices[1].push(new THREE.Vector3(B.x, irimoya_y, irimoya_z));
                irimoya_z += (C.z - A.z) / irimoya_steps;
              }

              irimoya_line_vertices[2].push(new THREE.Vector3(C.x, C.y, C.z));
              irimoya_line_vertices[2].push(new THREE.Vector3(D.x, D.y, D.z));

              irimoya_line.forEach(function(it) {
                scene.remove(it);
              })

              irimoya_line = [];
              for (let j=0; j<3; j++) {
                irimoya_line.push(new THREE.Line( new THREE.Geometry, new THREE.LineBasicMaterial({color: 0x0000FF})));
                irimoya_line[j].geometry.vertices = irimoya_line_vertices[j];
                scene.add(irimoya_line[j]);
              }
            }

            A.x -= change_level.x;
            A.y += change_level.y;
            A.z -= change_level.z;
            B.x += change_level.x;
            B.y += change_level.y;
            B.z += change_level.z;
            C.x -= change_level.x;
            C.y += change_level.y;
            C.z -= change_level.z;
            D.x += change_level.x;
            D.y += change_level.y;
            D.z += change_level.z;
          }
        }

        function make_yane() {
          var initA = ref_point[2].clone(), initB = ref_point[3].clone(), initC = ref_point[4].clone();
          var initD = ref_point[5].clone();

          var change_level = new THREE.Vector3(
            (initD.x - initB.x) / (yagura_steps - 1),
            (initD.y - initB.y) / yagura_steps,
            (initD.z - initB.z) / (yagura_steps - 1)
          )

          var A = new THREE.Vector3(
            initA.x + change_level.x,
            initA.y + 5 * change_level.y / 6,
            initA.z + change_level.z,
          )
          var B = new THREE.Vector3(
            initB.x - change_level.x,
            initB.y + 5 * change_level.y / 6,
            initB.z - change_level.z,
          )
          var C = new THREE.Vector3(
            initA.x - change_level.x,
            initA.y + 8 * change_level.y / 6,
            initA.z - change_level.z,
          )
          var D = new THREE.Vector3(
            initB.x + change_level.x,
            initB.y + 8 * change_level.y / 6,
            initB.z + change_level.z,
          )

          var taruki_interval_x = -1 * change_level.x / 8;
          if (taruki_interval_x == 0.0) taruki_interval_x = 0.1;
          var taruki_interval_z = -1 * change_level.z / 8;
          if (taruki_interval_z == 0.0) taruki_interval_z = 0.1;
          var init_taruki_num_x = Math.round((initB.x - initA.x) / taruki_interval_x);
          var init_taruki_num_z = Math.round((initB.z - initA.z) / taruki_interval_z);
          var sei = change_level.y / 2 / init_taruki_num_x * 10;

          var taruki_index = 0;

          for (let i=0; i<yagura_steps; i++) {
            var taruki_num_x = Math.round((B.x - A.x) / taruki_interval_x);
            var taruki_num_z = Math.round((B.z - A.z) / taruki_interval_z);

            var yane_x = A.x;
            var yane_y = A.y;
            var yane_z = A.z;
            for (let direction=0; direction<4; direction++) {
              var yane_geometry = new THREE.Geometry();
              var kayaoi = new THREE.Geometry();
              var taruki_num;

              if (direction % 2 == 0) {
                taruki_num = taruki_num_x;
              } else {
                taruki_num = taruki_num_z;
              }

              if (taruki_num > 100) taruki_num = 100;

              var count = 0;

              // yane_geometry.vertices.push(new THREE.Vector3(A.x, A.y + sei, A.z));
              // yane_geometry.vertices.push(new THREE.Vector3(A.x, A.y + sei, A.z));

              for (let j=0; j<taruki_num; j++) {
                if (j < 8) {
                  yane_y = A.y + sei * (8-j-1) * (8-j) / 8 / 7;
                } else if (j > taruki_num - 8) {
                  yane_y = A.y + sei * count * (count+1) / 8 / 7;
                  // console.log(yane_y);
                  count++;
                } else {
                  yane_y = A.y;
                }

                if (j % 1 == 0) {
                  yane_geometry.vertices.push(new THREE.Vector3(yane_x, yane_y, yane_z))
                  kayaoi.vertices.push(new THREE.Vector3(yane_x, yane_y, yane_z))

                  var taruki = new THREE.Geometry();
                  if (direction==0) {
                    var grad = (C.z - A.z) / (C.x - A.x);
                    var chany = C.y, chanz = change_level.z * 2;
                    if (-(yane_x - A.x) > change_level.x*2) {
                      chanz = grad * (A.x - yane_x);
                      chany = calc_sumimune(A.x, A.y+sei, A.z, C.x, C.y, C.z, yane_x, yane_z - chanz);
                    } else if ((yane_x - B.x) > change_level.x*2) {
                      chanz = grad * -(B.x - yane_x);
                      chany = calc_sumimune(B.x, A.y+sei, A.z, D.x, C.y, C.z, yane_x, yane_z - chanz);
                    }
                    yane_geometry.vertices.push(new THREE.Vector3(yane_x, chany, yane_z - chanz));

                    if (j % 4 == 2) {

                      var taruki_y = change_level.y * chanz / change_level.z / 8;
                      taruki.vertices.push(new THREE.Vector3(yane_x + taruki_interval_x, yane_y - taruki_interval_x, yane_z));
                      taruki.vertices.push(new THREE.Vector3(yane_x, yane_y - taruki_interval_x, yane_z));
                      taruki.vertices.push(new THREE.Vector3(yane_x, yane_y + taruki_y - taruki_interval_x*2, yane_z - chanz));
                      taruki.vertices.push(new THREE.Vector3(yane_x + taruki_interval_x, yane_y + taruki_y - taruki_interval_x*2, yane_z - chanz));

                      for (let k=0; k<4; k++) {
                        var t = taruki.vertices[k];
                        taruki.vertices.push(new THREE.Vector3(t.x, t.y - taruki_interval_x, t.z));
                      }

            taruki.faces.push(new THREE.Face3( 0, 3, 1));
            taruki.faces.push(new THREE.Face3( 1, 3, 2));
            taruki.faces.push(new THREE.Face3( 0, 1, 4));
            taruki.faces.push(new THREE.Face3( 1, 5, 4));
            taruki.faces.push(new THREE.Face3( 1, 2, 5));
            taruki.faces.push(new THREE.Face3( 2, 6, 5));
            taruki.faces.push(new THREE.Face3( 2, 3, 6));
            taruki.faces.push(new THREE.Face3( 3, 7, 6));
            taruki.faces.push(new THREE.Face3( 3, 0, 7));
            taruki.faces.push(new THREE.Face3( 0, 4, 7));
            taruki.faces.push(new THREE.Face3( 4, 5, 6));
            taruki.faces.push(new THREE.Face3( 4, 6, 7));

                      taruki.computeFaceNormals();
                      taruki.computeVertexNormals();

                      var material = new THREE.MeshBasicMaterial({color: 0x555555});
                      var taruki_mesh = new THREE.Mesh(taruki, material);
                      scene.add(taruki_mesh);

                    }

                    kayaoi.vertices.push(new THREE.Vector3(yane_x, yane_y, yane_z + taruki_interval_x));
                    kayaoi.vertices.push(new THREE.Vector3(yane_x, yane_y - taruki_interval_x, yane_z + taruki_interval_x));
                    kayaoi.vertices.push(new THREE.Vector3(yane_x, yane_y - taruki_interval_x, yane_z));
                  } else if (direction==1) {
                    var grad = (D.x - B.x) / (C.z - A.z);
                    var chany = C.y, chanx = change_level.x * 2;
                    if (-(yane_z - A.z) < change_level.z*2) {
                      chanx = grad * -(A.z - yane_z);
                      chany = calc_sumimune(B.x, A.y, A.z, D.x, C.y, C.z, yane_x + chanx, yane_z);
                    } else if ((yane_z - B.z) < change_level.z*2) {
                      chanx = grad * (B.z - yane_z);
                      chany = calc_sumimune(B.x, B.y, B.z, D.x, D.y, D.z, yane_x + chanx, yane_z);
                    }
                    yane_geometry.vertices.push(new THREE.Vector3(yane_x + chanx, chany, yane_z));
                  } else if (direction==2) {
                    var grad = (C.z - A.z) / (C.x - A.x);
                    var chany = C.y, chanz = change_level.z * 2;
                    if ((yane_x - B.x) > change_level.x*2) {
                      chanz = grad * -(B.x - yane_x);
                      chany = calc_sumimune(B.x, A.y, B.z, D.x, C.y, D.z, yane_x, yane_z + chanz);
                    } else if (-(yane_x - A.x) > change_level.x*2) {
                      chanz = grad * (A.x - yane_x);
                      chany = calc_sumimune(A.x, A.y, B.z, C.x, C.y, D.z, yane_x, yane_z + chanz);
                    }
                    yane_geometry.vertices.push(new THREE.Vector3(yane_x, chany, yane_z + chanz));
                  } else if (direction==3) {
                    var grad = (D.x - B.x) / (C.z - A.z);
                    var chany = C.y, chanx = change_level.x * 2;
                    if ((yane_z - B.z) < change_level.z*2) {
                      chanx = grad * (B.z - yane_z);
                      chany = calc_sumimune(A.x, A.y, B.z, C.x, C.y, D.z, yane_x - chanx, yane_z);
                    } else if (-(yane_z - A.z) < change_level.z*2) {
                      chanx = grad * -(A.z - yane_z);
                      chany = calc_sumimune(A.x, A.y, A.z, C.x, C.y, C.z, yane_x - chanx, yane_z);
                    }
                    yane_geometry.vertices.push(new THREE.Vector3(yane_x - chanx, chany, yane_z));
                  }
                  // taruki_line[taruki_line.length - 1].geometry.vertices = taruki_line_vertices;
                  // scene.add(taruki_line[taruki_line.length - 1]);
                }

                if (direction==0) {
                  yane_x += (B.x - A.x) / taruki_num;
                } else if (direction==1) {
                  yane_z += (B.z - A.z) / taruki_num;
                } else if (direction==2) {
                  yane_x -= (B.x - A.x) / taruki_num;
                } else if (direction==3) {
                  yane_z -= (B.z - A.z) / taruki_num;
                }

                taruki_index++;
              }
              yane_geometry.vertices.push(new THREE.Vector3(yane_x, A.y+sei, yane_z));
              yane_geometry.vertices.push(new THREE.Vector3(yane_x, A.y+sei, yane_z));

              for (let j=0; j < yane_geometry.vertices.length - 1; j=j+2) {
                if (j+2 > yane_geometry.vertices.length - 1) break;
                yane_geometry.faces.push(new THREE.Face3(j, j+2, j+3));
                yane_geometry.faces.push(new THREE.Face3(j, j+3, j+1));
                console.log(j, j+3, yane_geometry.vertices.length);
              }

              for (let j=0; j+1 < kayaoi.vertices.length / 4 - 1; j++) {
                // if (j+8 > kayaoi.vertices.length - 1) break;
                for (let k=0; k<4; k++) {
                  if (k==3) {
                    kayaoi.faces.push(new THREE.Face3(4*j+k, 4*j+k+4, 4*j+k+1));
                    kayaoi.faces.push(new THREE.Face3(4*j+k, 4*j+k+1, 4*j+k-3));
                  } else {
                    kayaoi.faces.push(new THREE.Face3(4*j+k, 4*j+k+4, 4*j+k+5));
                    kayaoi.faces.push(new THREE.Face3(4*j+k, 4*j+k+5, 4*j+k+1));
                  }
                }
              }

              yane_geometry.computeFaceNormals();
              yane_geometry.computeVertexNormals();

              var material = new THREE.MeshBasicMaterial({color: 0x444444});
              var yane = new THREE.Mesh(yane_geometry, material);
              // scene.add(yane);

              kayaoi.computeFaceNormals();
              kayaoi.computeVertexNormals();

              var material = new THREE.MeshBasicMaterial({color: 0x999999});
              var kayaoi_mesh = new THREE.Mesh(kayaoi, material);
              scene.add(kayaoi_mesh);
            }

            // console.log(yane_geometry);

            // var sumimune_steps = 5;

            function calc_sumimune(Downx, Downy, Downz, Upx, Upy, Upz, x, z) {
              var horizontal_distance = Math.sqrt(Math.pow(Upx - Downx, 2) + Math.pow(Upz - Downz, 2));
              var grad = (Upy - (Downy + sei)) / Math.pow(horizontal_distance, 2);

              var yane_x = x - Downx, yane_y = Downy + sei, yane_z = z - Downz;

              yane_y = Downy + sei + grad * (Math.pow(yane_x, 2) + Math.pow(yane_z, 2));
              return (yane_y);
            }

            function make_sumizuno(Downx, Downy, Downz, Upx, Upy, Upz) {
              var sumizuno = new THREE.Geometry();
              var inv = taruki_interval_x / Math.sqrt(2.0);
              Downy += sei;

              sumizuno.vertices.push(new THREE.Vector3(Downx + inv, Downy - taruki_interval_x * 2, Downz + inv));
              sumizuno.vertices.push(new THREE.Vector3(Downx - inv, Downy - taruki_interval_x * 2, Downz - inv));
              sumizuno.vertices.push(new THREE.Vector3(Downx - inv, Downy - taruki_interval_x, Downz - inv));
              sumizuno.vertices.push(new THREE.Vector3(Downx + inv, Downy - taruki_interval_x, Downz + inv));
              sumizuno.vertices.push(new THREE.Vector3(Downx - change_level.x + inv, Downy + change_level.y / 6 - taruki_interval_x, Downz - change_level.z + inv));
              sumizuno.vertices.push(new THREE.Vector3(Downx - change_level.x - inv, Downy + change_level.y / 6 - taruki_interval_x, Downz - change_level.z - inv));
              sumizuno.vertices.push(new THREE.Vector3(Downx - change_level.x - inv, Downy + change_level.y / 6, Downz - change_level.z - inv));
              sumizuno.vertices.push(new THREE.Vector3(Downx - change_level.x + inv, Downy + change_level.y / 6, Downz - change_level.z + inv));


            sumizuno.faces.push(new THREE.Face3( 0, 3, 1));
            sumizuno.faces.push(new THREE.Face3( 1, 3, 2));
            sumizuno.faces.push(new THREE.Face3( 0, 1, 4));
            sumizuno.faces.push(new THREE.Face3( 1, 5, 4));
            sumizuno.faces.push(new THREE.Face3( 1, 2, 5));
            sumizuno.faces.push(new THREE.Face3( 2, 6, 5));
            sumizuno.faces.push(new THREE.Face3( 2, 3, 6));
            sumizuno.faces.push(new THREE.Face3( 3, 7, 6));
            sumizuno.faces.push(new THREE.Face3( 3, 0, 7));
            sumizuno.faces.push(new THREE.Face3( 0, 4, 7));
            sumizuno.faces.push(new THREE.Face3( 4, 5, 6));
            sumizuno.faces.push(new THREE.Face3( 4, 6, 7));
              sumizuno.computeFaceNormals();
              sumizuno.computeVertexNormals();

              var material = new THREE.MeshBasicMaterial({color: 0x999999});
              var sumizuno_mesh = new THREE.Mesh(sumizuno, material);
              scene.add(sumizuno_mesh);
            }

            make_sumizuno(A.x, A.y, A.z, C.x, C.y, C.z);
            make_sumizuno(A.x, A.y, B.z, C.x, C.y, D.z);
            make_sumizuno(B.x, B.y, B.z, D.x, D.y, D.z);
            make_sumizuno(B.x, A.y, A.z, D.x, C.y, C.z);

            // function render_sumimune_line(vertices_array, Downx, Downy, Downz, Upx, Upy, Upz) {
            //   var horizontal_distance = Math.sqrt(Math.pow(Upx - Downx, 2) + Math.pow(Upz - Downz, 2));
            //   var grad = (Upy - (Downy + sei)) / Math.pow(horizontal_distance, 2);

            //   var delta_x = (Upx - Downx) / sumimune_steps;
            //   var delta_z = (Upz - Downz) / sumimune_steps;
            //   var yane_x = Downx, yane_y = Downy + sei, yane_z = Downz;
            //   for (let j=0; j<=sumimune_steps; j++) {
            //     yane_y = Downy + sei + grad * Math.pow(j, 2) * (Math.pow(delta_x, 2) + Math.pow(delta_z, 2));
            //     vertices_array.push(new THREE.Vector3(yane_x, yane_y, yane_z));
            //     yane_x += delta_x;
            //     yane_z += delta_z;
            //   }
            // }

            // yane_line_vertices[1] = [];
            // render_sumimune_line(yane_line_vertices[1], A.x, A.y, A.z, C.x, C.y, C.z);

            // yane_line_vertices[2] = [];
            // render_sumimune_line(yane_line_vertices[2], A.x, A.y, B.z, C.x, C.y, D.z);
            // // yane_line_vertices[2].push(new THREE.Vector3(A.x, A.y, B.z));
            // // yane_line_vertices[2].push(new THREE.Vector3(C.x, C.y, D.z));
            // yane_line_vertices[3] = [];
            // render_sumimune_line(yane_line_vertices[3], B.x, B.y, B.z, D.x, D.y, D.z);
            // // yane_line_vertices[3].push(new THREE.Vector3(B.x, B.y, B.z));
            // // yane_line_vertices[3].push(new THREE.Vector3(D.x, D.y, D.z));
            // yane_line_vertices[4] = [];
            // render_sumimune_line(yane_line_vertices[4], B.x, A.y, A.z, D.x, C.y, C.z);
            // // yane_line_vertices[4].push(new THREE.Vector3(B.x, B.y, A.z));
            // // yane_line_vertices[4].push(new THREE.Vector3(D.x, D.y, C.z));
            // yane_line_vertices[5] = [];
            // // yane_line_vertices[5].push(new THREE.Vector3(C.x, C.y, C.z));
            // // yane_line_vertices[5].push(new THREE.Vector3(D.x, C.y, C.z));
            // // yane_line_vertices[5].push(new THREE.Vector3(D.x, C.y, D.z));
            // // yane_line_vertices[5].push(new THREE.Vector3(C.x, C.y, D.z));
            // // yane_line_vertices[5].push(new THREE.Vector3(C.x, C.y, C.z));
            // //// yane_line_vertices[5].push(new THREE.Vector3(D.x, C.y, D.z));

            // for (let j=0; j<6; j++) {
            //   let index = i * 6 + j;
            //   yane_line[index].geometry = new THREE.Geometry();
            //   yane_line[index].geometry.vertices = yane_line_vertices[j];
            //   yane_line[index].geometry.verticesNeedUpdate = true;
            //   yane_line[index].geometry.elementNeedUpdate = true;
            //   yane_line[index].geometry.computeFaceNormals();
            // }

            // if (i == 0 && i != yagura_steps - 1) {
            //   var hafu_ren = (A.z - B.z) / 5;
            //   var hafu_start = A.z - (A.z - B.z) / 2;
            //   var hafu_line_vertices = [];
            //   hafu_line_vertices[0] = [];
            //   hafu_line_vertices[1] = [];
            //   var hafu_steps = 6;

            //   var alpha = 0.45;
            //   var rho1 = 0.3, rho2 = 0.6, theta = Math.atan(0.28), H = hafu_ren * Math.tan(theta);
            //   var L = hafu_ren / Math.cos(theta), Dist = 0.08 * L;
            //   var hafu_z = new THREE.Vector2();
            //   var hafu_point = new THREE.Vector2();
            //   for (let j=0; j<=hafu_steps*2; j++) {
            //     if (j<=hafu_steps) {
            //       var r1 = rho1 * Dist;
            //       hafu_z.x = alpha * j * L / hafu_steps;
            //       hafu_z.y = r1 * Math.sin(Math.PI * j / hafu_steps);

            //     } else {
            //       var r2 = rho2 * Dist;
            //       hafu_z.x = (alpha * hafu_steps + (1 - alpha) * (j - hafu_steps)) * L / hafu_steps;
            //       hafu_z.y = r2 * Math.sin(Math.PI * j / hafu_steps);
            //     }
            //       hafu_point.x = hafu_z.x * Math.cos(theta) + hafu_z.y * Math.sin(theta);
            //       hafu_point.y = H - hafu_z.x * Math.sin(theta) + hafu_z.y * Math.cos(theta);
            //       hafu_line_vertices[0].push(new THREE.Vector3(B.x, B.y + hafu_point.y, hafu_start + hafu_point.x));
            //       hafu_line_vertices[1].push(new THREE.Vector3(B.x, B.y + hafu_point.y, hafu_start - hafu_point.x));
            //   }

            //   hafu_line.push(new THREE.Line( new THREE.Geometry, new THREE.LineBasicMaterial({color: 0x0000FF})));
            //   hafu_line[0].geometry.vertices = hafu_line_vertices[0];
            //   // scene.add(hafu_line[0]);
            //   hafu_line.push(new THREE.Line( new THREE.Geometry, new THREE.LineBasicMaterial({color: 0x0000FF})));
            //   hafu_line[1].geometry.vertices = hafu_line_vertices[1];
            //   // scene.add(hafu_line[1]);
            // }

            // if (i == 1 && i != yagura_steps - 1) {
            //   var hafu_ren = (B.x - A.x) / 2;
            //   var hafu_start = A.x + (B.x - A.x) / 2 - hafu_ren / 2;
            //   var hafu_line_vertices = [];
            //   hafu_line_vertices[0] = [];
            //   var hafu_steps = 5;
            //   var hafu_x = hafu_start, hafu_y, hafu_z = A.z - change_level.z / 3;
            //   var L = Math.sqrt(Math.pow(hafu_ren / 2, 2) + Math.pow(change_level.y, 2));
            //   var theta = Math.atan(change_level.y / (hafu_ren / 2));
            //   var alpha = 0.5;
            //   for (let j=0; j<=hafu_steps*2; j++) {
            //     var step = j <= hafu_steps ? j : hafu_steps*2 - j;
            //     hafu_y = A.y + step * L / hafu_steps * (Math.sin(theta) - alpha * (hafu_steps - step) / hafu_steps * Math.cos(theta));
            //     hafu_line_vertices[0].push(new THREE.Vector3(hafu_x, hafu_y, hafu_z));
            //     hafu_x += hafu_ren / 2 / hafu_steps;
            //   }

            //   hafu_line.push(new THREE.Line( new THREE.Geometry, new THREE.LineBasicMaterial({color: 0x0000FF})));
            //   hafu_line[hafu_line.length - 1].geometry.vertices = hafu_line_vertices[0];
            //   // scene.add(hafu_line[hafu_line.length - 1]);
            // }

            // if (i == yagura_steps - 1) {
            //   A.x -= 3 * change_level.x / 4;
            //   B.x += 3 * change_level.x / 4;
            //   A.z -= 3 * change_level.z / 4;
            //   B.z += 3 * change_level.z / 4;
            //   C.x = A.x;
            //   D.x = B.x;
            //   C.y += change_level.y / 3;
            //   D.y += change_level.y / 3;
            //   C.z = (C.z + D.z) / 2;
            //   D.z = C.z;

            //   var irimoya_line_vertices = [];
            //   irimoya_line_vertices[0] = [];
            //   irimoya_line_vertices[1] = [];
            //   irimoya_line_vertices[2] = [];
            //   var irimoya_steps = 5;
            //   var irimoya_z = A.z, irimoya_y = A.y;
            //   var L = Math.sqrt(Math.pow(C.z - A.z, 2) + Math.pow(C.y - A.y, 2));
            //   var theta = -1 * Math.atan((C.y - A.y) / (C.z - A.z));
            //   var alpha = 0.5;
            //   for (let j=0; j<=irimoya_steps*2; j++) {
            //     var step = j <= irimoya_steps ? j : irimoya_steps*2 - j;
            //     irimoya_y = A.y + step * L / irimoya_steps * (Math.sin(theta) - alpha * (irimoya_steps - step) / irimoya_steps * Math.cos(theta));
            //     irimoya_line_vertices[0].push(new THREE.Vector3(A.x, irimoya_y, irimoya_z));
            //     irimoya_z += (C.z - A.z) / irimoya_steps;
            //   }

            //   irimoya_z = A.z;
            //   for (let j=0; j<=irimoya_steps*2; j++) {
            //     var step = j <= irimoya_steps ? j : irimoya_steps*2 - j;
            //     irimoya_y = A.y + step * L / irimoya_steps * (Math.sin(theta) - alpha * (irimoya_steps - step) / irimoya_steps * Math.cos(theta));
            //     irimoya_line_vertices[1].push(new THREE.Vector3(B.x, irimoya_y, irimoya_z));
            //     irimoya_z += (C.z - A.z) / irimoya_steps;
            //   }

            //   irimoya_line_vertices[2].push(new THREE.Vector3(C.x, C.y, C.z));
            //   irimoya_line_vertices[2].push(new THREE.Vector3(D.x, D.y, D.z));

            //   irimoya_line.forEach(function(it) {
            //     scene.remove(it);
            //   })

            //   irimoya_line = [];
            //   for (let j=0; j<3; j++) {
            //     irimoya_line.push(new THREE.Line( new THREE.Geometry, new THREE.LineBasicMaterial({color: 0x0000FF})));
            //     irimoya_line[j].geometry.vertices = irimoya_line_vertices[j];
            //     scene.add(irimoya_line[j]);
            //   }
            // }

            A.x -= change_level.x;
            A.y += change_level.y;
            A.z -= change_level.z;
            B.x += change_level.x;
            B.y += change_level.y;
            B.z += change_level.z;
            C.x -= change_level.x;
            C.y += change_level.y;
            C.z -= change_level.z;
            D.x += change_level.x;
            D.y += change_level.y;
            D.z += change_level.z;
          }
        }

        window.addEventListener('click', function(e) {
          if (build_mode) {
            if (click_count == 0) {
              ref_point[0] = mouse_on_y0plane.clone();
              var m = new THREE.Mesh(geometry, material);
              scene.add(m);
              m.position.set(ref_point[0].x, ref_point[0].y, ref_point[0].z);
              // ref_point[0] ... 最初に決めた点(地面上)
              click_count++;
              scene.add(rec_y0plane); // 補助線追加
              // console.log(ref_point[0]);
            } else if (click_count == 1) {
              ref_point[1] = mouse_on_y0plane.clone();
              var m = new THREE.Mesh(geometry, material);
              scene.add(m);
              m.position.set(ref_point[1].x, ref_point[1].y, ref_point[1].z);
              // ref_point[1] ... 最初に決めた点と対角線上にある地面上の点
              for (let i=0; i<5*ishigaki_steps; i++) scene.add(ishigaki_line[i]);
              click_count++;
            } else if (click_count == 2) {
              ref_point[3] = mouse_on_2pplane.clone();
              if (ref_point[3].y < 0) ref_point[3].y = 0;
              ref_point[2] = new THREE.Vector3(
                ref_point[1].x - (ref_point[3].x - ref_point[0].x),
                ref_point[3].y,
                ref_point[1].z - (ref_point[3].z - ref_point[0].z)
              );
              var m = new THREE.Mesh(geometry, material);
              scene.add(m);
              m.position.set(ref_point[3].x, ref_point[3].y, ref_point[3].z);
              // ref_point[3] ... 0と1の点を通る、地面に垂直な平面上の点。石垣の上面の1と同じ側にある点
              // ref_point[2] ... 3と対角線上にある点。石垣の上面の0と同じ側にある点
              for (let i=0; i<5*ishigaki_steps; i++) scene.remove(ishigaki_line[i]);
              make_ishigaki();
              make_yagura_line();
              make_yane_line();
              click_count++;
            } else if (click_count == 3) {
              ref_point[5] = mouse_on_2pplane.clone();
              if (ref_point[5].x > ref_point[3].x) ref_point[5].x = ref_point[3].x;
              if (ref_point[5].x < (ref_point[3].x + ref_point[2].x) / 2) ref_point[5].x = (ref_point[3].x + ref_point[2].x) / 2;
              if (ref_point[5].y < 0) ref_point[5].y = 0;
              if (ref_point[5].z < ref_point[3].z) ref_point[5].z = ref_point[3].z;
              if (ref_point[5].z > (ref_point[3].z + ref_point[2].z) / 2) ref_point[5].z = (ref_point[3].z + ref_point[2].z) / 2;
              ref_point[4] = new THREE.Vector3(
                ref_point[3].x - (ref_point[5].x - ref_point[2].x),
                ref_point[5].y,
                ref_point[3].z - (ref_point[5].z - ref_point[2].z)
              );
              make_yagura();
              make_yane();
              remove_yagura_line();
              click_count++;
            }
          }
        }, false);

        function make_ishigaki() {
          var initA = ref_point[0].clone(), initB = ref_point[1].clone(), initC = ref_point[2].clone();
          var initD = ref_point[3].clone();

          var A = initA.clone(), B = initB.clone();
          var C = A.clone(), D = B.clone();

          var h = initC.y - initA.y;
          var b_x = (initA.x - initC.x) * 50/44;
          var b_z = (initA.z - initC.z) * 50/44;
          var d_x = (initA.x - initC.x) * 6/44;
          var d_z = (initA.z - initC.z) * 6/44;

          var delta_x = ishigaki_steps / (ishigaki_steps - 1) * d_x / h;
          var delta_z = ishigaki_steps / (ishigaki_steps - 1) * d_z / h;

          function r(axis, sub) {
            let n = ishigaki_steps;

            if (axis == 0) {
              var r = b_x / h;
              if (sub == n - 1) {
                return r;
              } else {
                for (let i = (n-1); i > sub; i--) {
                  if (i != 0) r -= delta_x / i;
                }
                return r;
              }
            }

            if (axis == 2) {
              var r = b_z / h;
              if (sub == n - 1) {
                return r;
              } else {
                for (let i = (n-1); i > sub; i--) {
                  if (i != 0) r -= delta_z / i;
                }
                return r;
              }
            }
          }

          function change_level(axis, sub) {
            if (axis == 1) {
              return h / ishigaki_steps;
            } else {
              return r(axis, sub) * h / ishigaki_steps;
            }
          }

          for (let i = 0; i < ishigaki_steps; i++) {

            C.x -= change_level(0, (ishigaki_steps-1)-i);
            C.y += change_level(1, (ishigaki_steps-1)-i);
            C.z -= change_level(2, (ishigaki_steps-1)-i);
            D.x += change_level(0, (ishigaki_steps-1)-i);
            D.y += change_level(1, (ishigaki_steps-1)-i);
            D.z += change_level(2, (ishigaki_steps-1)-i);

            var geometry = new THREE.Geometry();

            // 下側の四角
            geometry.vertices.push(new THREE.Vector3(A.x, A.y, A.z)); //V0
            geometry.vertices.push(new THREE.Vector3(B.x, A.y, A.z)); //V1
            geometry.vertices.push(new THREE.Vector3(B.x, A.y, B.z)); //V2
            geometry.vertices.push(new THREE.Vector3(A.x, A.y, B.z)); //V3
            // 上側の四角
            geometry.vertices.push(new THREE.Vector3(C.x, C.y, C.z)); //V4
            geometry.vertices.push(new THREE.Vector3(D.x, C.y, C.z)); //V5
            geometry.vertices.push(new THREE.Vector3(D.x, C.y, D.z)); //V6
            geometry.vertices.push(new THREE.Vector3(C.x, C.y, D.z)); //V7

             //    V7-------V6
             //   / \       |\
             //  /  V4-------V5
             // V3--/-------V2 \
             //  \ /          \ \
             //   V0-----------V1
             console.log(geometry.vertices)

            geometry.faces.push(new THREE.Face3( 0, 3, 1));
            geometry.faces.push(new THREE.Face3( 1, 3, 2));
            geometry.faces.push(new THREE.Face3( 0, 1, 4));
            geometry.faces.push(new THREE.Face3( 1, 5, 4));
            geometry.faces.push(new THREE.Face3( 1, 2, 5));
            geometry.faces.push(new THREE.Face3( 2, 6, 5));
            geometry.faces.push(new THREE.Face3( 2, 3, 6));
            geometry.faces.push(new THREE.Face3( 3, 7, 6));
            geometry.faces.push(new THREE.Face3( 3, 0, 7));
            geometry.faces.push(new THREE.Face3( 0, 4, 7));
            geometry.faces.push(new THREE.Face3( 4, 5, 6));
            geometry.faces.push(new THREE.Face3( 4, 6, 7));

            geometry.computeFaceNormals();
            geometry.computeVertexNormals();

            var material = new THREE.MeshNormalMaterial();
            //var material = new THREE.MeshPhongMaterial({color: 0x88FFFF});
            var material = new THREE.MeshBasicMaterial({color: 0xB69F84});
            ishigaki_geometry[i] = new THREE.Mesh(geometry, material);
            scene.add(ishigaki_geometry[i]);

            A = C.clone();
            B = D.clone();
          }
        }

        function make_yagura_line() {
          yagura_line.forEach(function(i) {
            scene.remove(i);
          })
          yagura_line = [];
          for (let i=0; i<yagura_steps*6; i++) {
            yagura_line[i] = (new THREE.Line( new THREE.Geometry, new THREE.LineBasicMaterial({color: 0xFFFFFF})));
            scene.add(yagura_line[i]);
          }
        }

        function make_yane_line() {
          yane_line.forEach(function(i) {
            scene.remove(i);
          })
          yane_line = [];
          for (let i=0; i<yagura_steps*6; i++) {
            yane_line[i] = (new THREE.Line( new THREE.Geometry, new THREE.LineBasicMaterial({color: 0x0000FF})));
            scene.add(yane_line[i]);
          }
        }

        function remove_taruki_line() {
          taruki_line.forEach(function(i) {
            scene.remove(i);
          })
          taruki_line = [];
        }

        function add_taruki_line(taruki_num) {
          for (let i=0; i<taruki_num; i++) {
            taruki_line.push(new THREE.Line( new THREE.Geometry, new THREE.LineBasicMaterial({color: 0x0000FF})));
            scene.add(taruki_line[taruki_line.length - 1]);
          }
        }

        function remove_yagura_line() {
          yagura_line.forEach(function(i) {
            scene.remove(i);
          })          
        }

        function make_yagura() {
          var initA = ref_point[2].clone(), initB = ref_point[3].clone(), initC = ref_point[4].clone();
          var initD = ref_point[5].clone();

          var change_level = new THREE.Vector3(
            (initD.x - initB.x) / (yagura_steps - 1),
            (initD.y - initB.y) / yagura_steps,
            (initD.z - initB.z) / (yagura_steps - 1)
          )

          var A = initA.clone();
          var B = initB.clone();
          var C = new THREE.Vector3(
            initA.x,
            initA.y + change_level.y,
            initA.z,
          )
          var D = new THREE.Vector3(
            initB.x,
            initB.y + change_level.y,
            initB.z,
          )

          for (let i=0; i<yagura_steps; i++) {
            var geometry = new THREE.Geometry();

            // if (i == yagura_steps - 1) {
            //   C.y -= change_level.y / 2;
            //   D.y = C.y;
            // }

            // 下側の四角
            geometry.vertices.push(new THREE.Vector3(A.x, A.y, A.z)); //V0
            geometry.vertices.push(new THREE.Vector3(B.x, A.y, A.z)); //V1
            geometry.vertices.push(new THREE.Vector3(B.x, A.y, B.z)); //V2
            geometry.vertices.push(new THREE.Vector3(A.x, A.y, B.z)); //V3
            // 上側の四角
            geometry.vertices.push(new THREE.Vector3(C.x, C.y, C.z)); //V4
            geometry.vertices.push(new THREE.Vector3(D.x, C.y, C.z)); //V5
            geometry.vertices.push(new THREE.Vector3(D.x, C.y, D.z)); //V6
            geometry.vertices.push(new THREE.Vector3(C.x, C.y, D.z)); //V7

             // V7-------V6
             // |\       |\
             // | V4-------V5
             // V3-|-----V2-|
             //  \ |       \|
             //   V0--------V1

            geometry.faces.push(new THREE.Face3( 0, 3, 1));
            geometry.faces.push(new THREE.Face3( 1, 3, 2));
            geometry.faces.push(new THREE.Face3( 0, 1, 4));
            geometry.faces.push(new THREE.Face3( 1, 5, 4));
            geometry.faces.push(new THREE.Face3( 1, 2, 5));
            geometry.faces.push(new THREE.Face3( 2, 6, 5));
            geometry.faces.push(new THREE.Face3( 2, 3, 6));
            geometry.faces.push(new THREE.Face3( 3, 7, 6));
            geometry.faces.push(new THREE.Face3( 3, 0, 7));
            geometry.faces.push(new THREE.Face3( 0, 4, 7));
            geometry.faces.push(new THREE.Face3( 4, 5, 6));
            geometry.faces.push(new THREE.Face3( 4, 6, 7));

            geometry.computeFaceNormals();
            geometry.computeVertexNormals();

            // var material = new THREE.MeshNormalMaterial();
            //var material = new THREE.MeshPhongMaterial({color: 0x88FFFF});
            var material = new THREE.MeshBasicMaterial({color: 0xCBC9D4, vertexColors: THREE.FaceColors});
            yagura_geometry[i] = new THREE.Mesh(geometry, material);
            scene.add(yagura_geometry[i]);

            A.x -= change_level.x;
            A.y += change_level.y;
            A.z -= change_level.z;
            B.x += change_level.x;
            B.y += change_level.y;
            B.z += change_level.z;
            C.x -= change_level.x;
            C.y += change_level.y;
            C.z -= change_level.z;
            D.x += change_level.x;
            D.y += change_level.y;
            D.z += change_level.z;
          }
        }

        function make_yane_old() {
          var initA = ref_point[2].clone(), initB = ref_point[3].clone(), initC = ref_point[4].clone();
          var initD = ref_point[5].clone();

          var change_level = new THREE.Vector3(
            (initD.x - initB.x) / (yagura_steps - 1),
            (initD.y - initB.y) / yagura_steps,
            (initD.z - initB.z) / (yagura_steps - 1)
          )

          var A = new THREE.Vector3(
            initA.x + change_level.x,
            initA.y + 1 * change_level.y / 1,
            initA.z + change_level.z,
          )
          var B = new THREE.Vector3(
            initB.x - change_level.x,
            initB.y + 1 * change_level.y / 1,
            initB.z - change_level.z,
          )
          var C = new THREE.Vector3(
            initA.x - change_level.x,
            initA.y + 3 * change_level.y / 2,
            initA.z - change_level.z,
          )
          var D = new THREE.Vector3(
            initB.x + change_level.x,
            initB.y + 3 * change_level.y / 2,
            initB.z + change_level.z,
          )

          for (let i=0; i<yagura_steps; i++) {
            var geometry = new THREE.Geometry();

            if (i == yagura_steps - 1) {
              A.x -= 3 * change_level.x / 4;
              B.x += 3 * change_level.x / 4;
              C.x = A.x;
              D.x = B.x;
              C.y += change_level.y / 3;
              D.y += change_level.y / 3;
              C.z = (C.z + D.z) / 2;
              D.z = C.z;
            }

            // 下側の四角
            geometry.vertices.push(new THREE.Vector3(A.x, A.y, A.z)); //V0
            geometry.vertices.push(new THREE.Vector3(B.x, A.y, A.z)); //V1
            geometry.vertices.push(new THREE.Vector3(B.x, A.y, B.z)); //V2
            geometry.vertices.push(new THREE.Vector3(A.x, A.y, B.z)); //V3
            // 上側の四角
            geometry.vertices.push(new THREE.Vector3(C.x, C.y, C.z)); //V4
            geometry.vertices.push(new THREE.Vector3(D.x, C.y, C.z)); //V5
            geometry.vertices.push(new THREE.Vector3(D.x, C.y, D.z)); //V6
            geometry.vertices.push(new THREE.Vector3(C.x, C.y, D.z)); //V7

             // V7-------V6
             // |\       |\
             // | V4-------V5
             // V3-|-----V2-|
             //  \ |       \|
             //   V0--------V1

            geometry.faces.push(new THREE.Face3( 0, 3, 1));
            geometry.faces.push(new THREE.Face3( 1, 3, 2));
            geometry.faces.push(new THREE.Face3( 0, 1, 4));
            geometry.faces.push(new THREE.Face3( 1, 5, 4));
            geometry.faces.push(new THREE.Face3( 1, 2, 5));
            geometry.faces.push(new THREE.Face3( 2, 6, 5));
            geometry.faces.push(new THREE.Face3( 2, 3, 6));
            geometry.faces.push(new THREE.Face3( 3, 7, 6));
            geometry.faces.push(new THREE.Face3( 3, 0, 7));
            geometry.faces.push(new THREE.Face3( 0, 4, 7));
            geometry.faces.push(new THREE.Face3( 4, 5, 6));
            geometry.faces.push(new THREE.Face3( 4, 6, 7));

            geometry.computeFaceNormals();
            geometry.computeVertexNormals();

            // var material = new THREE.MeshNormalMaterial();
            //var material = new THREE.MeshPhongMaterial({color: 0x88FFFF});
            var material = new THREE.MeshBasicMaterial({color: 0x444444, vertexColors: THREE.FaceColors});
            yagura_geometry[i] = new THREE.Mesh(geometry, material);
            scene.add(yagura_geometry[i]);

            A.x -= change_level.x;
            A.y += change_level.y;
            A.z -= change_level.z;
            B.x += change_level.x;
            B.y += change_level.y;
            B.z += change_level.z;
            C.x -= change_level.x;
            C.y += change_level.y;
            C.z -= change_level.z;
            D.x += change_level.x;
            D.y += change_level.y;
            D.z += change_level.z;
          }

        }

        function render_taruki_line() {
          var initA = ref_point[2].clone(), initB = ref_point[3].clone(), initC = ref_point[4].clone();
          var initD = ref_point[5].clone();

          var change_level = new THREE.Vector3(
            (initD.x - initB.x) / (yagura_steps - 1),
            (initD.y - initB.y) / yagura_steps,
            (initD.z - initB.z) / (yagura_steps - 1)
          )

          var A = new THREE.Vector3(
            initA.x + change_level.x,
            initA.y + 1 * change_level.y / 1,
            initA.z + change_level.z,
          )
          var B = new THREE.Vector3(
            initB.x - change_level.x,
            initB.y + 1 * change_level.y / 1,
            initB.z - change_level.z,
          )
          var C = new THREE.Vector3(
            initA.x - change_level.x,
            initA.y + 3 * change_level.y / 2,
            initA.z - change_level.z,
          )
          var D = new THREE.Vector3(
            initB.x + change_level.x,
            initB.y + 3 * change_level.y / 2,
            initB.z + change_level.z,
          )

          var taruki_interval_x = -1 * change_level.x / 8;
          if (taruki_interval_x == 0.0) taruki_interval_x = 0.1;
          var taruki_interval_z = -1 * change_level.z / 8;
          if (taruki_interval_z == 0.0) taruki_interval_z = 0.1;
          var init_taruki_num_x = Math.round((initB.x - initA.x) / taruki_interval_x);
          var init_taruki_num_z = Math.round((initB.z - initA.z) / taruki_interval_z);
          var sei = change_level.y / 2 / init_taruki_num_x * 10;

          for (let i=0; i<yagura_steps; i++) {
            var taruki_line_vertices = [];

            var taruki_num_x = Math.round((B.x - A.x) / taruki_interval_x);
            var taruki_num_z = Math.round((B.z - A.z) / taruki_interval_z);

            var yane_x = A.x;
            var yane_y = A.y;
            var yane_z = A.z;

            for (let direction=0; direction<4; direction++) {
              var taruki_num;
              if (direction % 2 == 0) {
                taruki_num = taruki_num_x;
              } else {
                taruki_num = taruki_num_z;
              }

              if (taruki_num > 100) taruki_num = 100;

              var count = 0;

              for (let j=0; j<taruki_num; j++) {
                if (j < 8) {
                  yane_y = A.y + sei * (8-j-1) * (8-j) / 8 / 7;
                } else if (j > taruki_num - 8) {
                  yane_y = A.y + sei * count * (count+1) / 8 / 7;
                  // console.log(yane_y);
                  count++;
                } else {
                  yane_y = A.y;
                }
                yane_line_vertices[0].push(new THREE.Vector3(yane_x, yane_y, yane_z));

                if (direction==0) {
                  yane_x += (B.x - A.x) / taruki_num;
                } else if (direction==1) {
                  yane_z += (B.z - A.z) / taruki_num;
                } else if (direction==2) {
                  yane_x -= (B.x - A.x) / taruki_num;
                } else if (direction==3) {
                  yane_z -= (B.z - A.z) / taruki_num;
                }
              }
            }
          }
        }

        window.addEventListener( 'resize', onWindowResize, false );

        window.addEventListener( 'keydown', function ( event ) {

          switch ( event.keyCode ) {
            case 66: // B
              build_mode = !build_mode;

              console.log(build_mode);
              break;

            case 69: // E
              edit_mode = !edit_mode;

              console.log(edit_mode);
              break;

            case 81: // Q
              control.setSpace( control.space === "local" ? "world" : "local" );
              break;

            case 16: // Shift
              control.setTranslationSnap( 100 );
              control.setRotationSnap( THREE.MathUtils.degToRad( 15 ) );
              control.setScaleSnap( 0.25 );
              break;

            case 87: // W
              control.setMode( "translate" );
              break;

            case 69: // E
              control.setMode( "rotate" );
              break;

            case 82: // R
              control.setMode( "scale" );
              break;

            case 67: // C
              const position = currentCamera.position.clone();

              currentCamera = currentCamera.isPerspectiveCamera ? cameraOrtho : cameraPersp;
              currentCamera.position.copy( position );

              orbit.object = currentCamera;
              control.camera = currentCamera;

              currentCamera.lookAt( orbit.target.x, orbit.target.y, orbit.target.z );
              onWindowResize();
              break;

            case 86: // V
              const randomFoV = Math.random() + 0.1;
              const randomZoom = Math.random() + 0.1;

              cameraPersp.fov = randomFoV * 160;
              cameraOrtho.bottom = - randomFoV * 500;
              cameraOrtho.top = randomFoV * 500;

              cameraPersp.zoom = randomZoom * 5;
              cameraOrtho.zoom = randomZoom * 5;
              onWindowResize();
              break;

            case 187:
            case 107: // +, =, num+
              control.setSize( control.size + 0.1 );
              break;

            case 189:
            case 109: // -, _, num-
              control.setSize( Math.max( control.size - 0.1, 0.1 ) );
              break;

            case 88: // X
              control.showX = ! control.showX;
              break;

            case 89: // Y
              control.showY = ! control.showY;
              break;

            case 90: // Z
              control.showZ = ! control.showZ;
              break;

            case 32: // Spacebar
              control.enabled = ! control.enabled;
              break;

          }

          if (48 < event.keyCode && event.keyCode < 58) {
            yagura_steps = event.keyCode - 48;
            console.log(yagura_steps)
            make_yagura_line();
          }

        } );

        window.addEventListener( 'keyup', function ( event ) {

          switch ( event.keyCode ) {

            case 16: // Shift
              control.setTranslationSnap( null );
              control.setRotationSnap( null );
              control.setScaleSnap( null );
              break;

          }

        } );

      }

      function onWindowResize() {

        const aspect = window.innerWidth / window.innerHeight;

        cameraPersp.aspect = aspect;
        cameraPersp.updateProjectionMatrix();

        cameraOrtho.left = cameraOrtho.bottom * aspect;
        cameraOrtho.right = cameraOrtho.top * aspect;
        cameraOrtho.updateProjectionMatrix();

        renderer.setSize( window.innerWidth, window.innerHeight );

        render();

      }

      function render() {

        renderer.render( scene, currentCamera );

      }

    </script>

  </body>
</html>